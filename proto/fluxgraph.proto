// FluxGraph gRPC Service Protocol
// 
// FluxGraph is a physics simulation service that accepts signal updates from
// multiple providers and returns physics-driven state changes and commands.
//
// Design Principles:
// - Provider-agnostic: No assumptions about client implementation
// - Server-driven tick: Server decides when to advance simulation time
// - Multi-provider: Multiple clients can share one physics graph
// - Type-safe: Typed command arguments (not string-string maps)

syntax = "proto3";

package fluxgraph.rpc;

// ============================================================================
// Main Service Definition
// ============================================================================

service FluxGraph {
  // Load physics graph configuration
  // idempotent: Multiple calls with same config_hash are no-ops
  rpc LoadConfig(ConfigRequest) returns (ConfigResponse);
  
  // Register a provider for command routing
  // Returns session_id that must be used in UpdateSignals
  rpc RegisterProvider(ProviderRegistration) returns (ProviderRegistrationResponse);

  // Explicitly unregister a provider session
  // Allows immediate barrier update on clean shutdown/restart
  rpc UnregisterProvider(UnregisterRequest) returns (UnregisterResponse);
  
  // Update signals from provider and get tick notification
  // Server may tick physics if all registered providers have updated
  // Returns tick_occurred flag and commands for THIS provider
  rpc UpdateSignals(SignalUpdates) returns (TickResponse);
  
  // Read current signal values
  // Used by providers to query physics-driven state
  rpc ReadSignals(SignalRequest) returns (SignalResponse);
  
  // Reset simulation to initial state
  rpc Reset(ResetRequest) returns (ResetResponse);
  
  // Health check (standard gRPC health protocol)
  rpc Check(HealthCheckRequest) returns (HealthCheckResponse);
}

// ============================================================================
// Configuration
// ============================================================================

message ConfigRequest {
  // Configuration content (YAML or JSON format)
  // Must contain: models, edges, rules (FluxGraph format)
  string config_content = 1;
  
  // Format: "yaml" or "json"
  string format = 2;
  
  // Optional: SHA256 hash for idempotency
  // If hash matches current config, server returns success without reload
  string config_hash = 3;
}

message ConfigResponse {
  bool success = 1;
  string error_message = 2;
  
  // True if config was reloaded, false if hash matched (no-op)
  bool config_changed = 3;
}

// ============================================================================
// Provider Registration
// ============================================================================

message ProviderRegistration {
  // Unique provider identifier (e.g., "chamber-provider")
  string provider_id = 1;
  
  // Devices this provider owns (for command routing)
  // Rules can emit commands with target device names
  repeated string device_ids = 2;
}

message ProviderRegistrationResponse {
  bool success = 1;
  string error_message = 2;
  
  // Session token - must be included in UpdateSignals
  // Unique per provider instance (handles reconnects)
  string session_id = 3;
}

message UnregisterRequest {
  // Session ID from RegisterProvider
  string session_id = 1;
}

message UnregisterResponse {
  bool success = 1;
  string error_message = 2;
}

// ============================================================================
// Signal Updates (Provider -> FluxGraph)
// ============================================================================

message SignalUpdate {
  // Signal path (e.g., "chamber.power", "motor.speed")
  // Must match signal paths defined in config edges
  string path = 1;
  
  // Signal value
  double value = 2;
  
  // Physical unit (e.g., "W", "degC", "m/s")
  // Server validates unit consistency
  string unit = 3;
}

message SignalUpdates {
  // Session ID from RegisterProvider
  string session_id = 1;
  
  // Signal updates from this provider
  repeated SignalUpdate signals = 2;
}

// ============================================================================
// Tick Response (FluxGraph -> Provider)
// ============================================================================

message TickResponse {
  // True if server advanced physics simulation this call
  // False if waiting for other providers to update
  bool tick_occurred = 1;
  
  // Current simulation time in seconds
  double sim_time_sec = 2;
  
  // Commands for THIS provider only (filtered by device ownership)
  // Generated by rules during physics tick
  repeated Command commands = 3;
}

message Command {
  // Target device name (matches device_ids from registration)
  string device = 1;
  
  // Function to call on device
  string function = 2;
  
  // Typed arguments
  map<string, CommandArg> args = 3;
}

message CommandArg {
  oneof value {
    double double_val = 1;
    int64 int_val = 2;
    bool bool_val = 3;
    string string_val = 4;
  }
}

// ============================================================================
// Signal Reads (Provider -> FluxGraph)
// ============================================================================

message SignalRequest {
  // Signal paths to read
  repeated string paths = 1;
}

message SignalValue {
  // Signal path
  string path = 1;
  
  // Current value
  double value = 2;
  
  // Physical unit
  string unit = 3;
  
  // True if this signal is owned by physics (not writeable by provider)
  // False if provider can write this signal
  bool physics_driven = 4;
}

message SignalResponse {
  repeated SignalValue signals = 1;
}

// ============================================================================
// Reset
// ============================================================================

message ResetRequest {
  // Reserved for future options (e.g., reset to specific time)
}

message ResetResponse {
  bool success = 1;
  string error_message = 2;
}

// ============================================================================
// Health Check (Standard gRPC Health Protocol)
// ============================================================================

message HealthCheckRequest {
  // Service name to check (empty or "fluxgraph")
  string service = 1;
}

message HealthCheckResponse {
  enum ServingStatus {
    UNKNOWN = 0;
    SERVING = 1;
    NOT_SERVING = 2;
    SERVICE_UNKNOWN = 3;
  }
  ServingStatus status = 1;
}
